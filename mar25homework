3.11

//linkedlist.h

#pragma once
#include <iostream>
using namespace std;

class linkedList
{
private:
	int data;
	linkedList *next;

public:
	int size();
	void addNode();
	void deleteNode(linkedList *head, int key);
	void print();
	bool hasValue(int key);
	linkedList *head;
};



//linkedlist.cpp

#include "linkedlist.h"

void linkedList::addNode()
{
	linkedList *temp = new linkedList;
	cout << "enter data to be added" << endl;
	cin >> temp->data;

	if (head == NULL)
	{
		head = temp;
	}

	else if (head->next == NULL)
	{
		head->next = temp;
	}

	else
	{
		linkedList *lead = head->next;
		while (lead->next != NULL)
		{
			if (lead->next == NULL)
			{
				lead->next = temp;
			}

			lead = lead->next;
		}
	}

}

void linkedList::deleteNode(linkedList *head, int key)
{
	linkedList *temp = head;
	linkedList *follow = head;

	if (temp != NULL && temp->data == key)
	{
		head = temp->next;
		return;
	}

	while (temp != NULL && temp->data != key)
	{
		follow = temp;
		temp = temp->next;
	}

	if (temp == NULL)
	{
		cout << "key was not in the list" << endl;
		return;
	}
	else
	{
		follow->next = temp->next;
		cout << "node successfully deleted" << endl;
	}
}

int linkedList::size()
{
	linkedList *temp = head;

	if (temp == NULL)
	{
		return 0;
	}

	else
	{
		int i = 0;
		while (temp != NULL)
		{
			temp = temp->next;
			i++;
		}
		return i;
	}
}

void linkedList::print()
{
	linkedList *temp = head;

	if (temp == NULL)
	{
		cout << "no items to print out" << endl;
	}

	else
	{
		while (temp != NULL)
		{
			cout << temp->data << endl;
			temp = temp->next;
		}
	}
}

bool linkedList::hasValue(int key)
{
	linkedList *temp = head;
	bool found = false;

	if (temp == NULL)
	{
		cout << "no items in the list" << endl;
	}

	else
	{
		while (temp != NULL)
		{
			if (temp->data == key)
			{
				found = true;
			}
			temp = temp->next;
		}
	}

	return found;
}


3.12

void linkedList::sortlist()
{
	bool unsorted = true;

	while (unsorted == true)
	{
		unsorted = false;
		linkedList *temp;
		temp = head;
		linkedList *next = temp->next;

		while (temp != NULL)
		{
			next = temp->next;
			if (next < temp)
			{
				swap(next, temp);
				unsorted = true;
			}
			temp = temp->next;
		}
	}
}


3.25
a) the data structure being described could just be a singly linked list with extra functionality. The push and pop are simply the same as addNode and deleteNode, with this being done each node could store the minValue up to that point (as in the minimum of all of the values before it but not after it). Therefore finding the min value would be saved in the last node of the list (and thus would take less than O(1).
b) the operation deleteMin would require a call of the memory that is already stored, holding the minimum value, then a loop would have to iterate through the list to find that value, at minimum it would be the head node, and at maximum it would be the last items in the list.

3.28
psuedo-code solution
push(x)
{
temp node - > data = x;
temp node2 = head;
head = head->next;
node = node2;
}

pop
{
head = head->next
}

inject(x)
{
temp node->data = x;
tail->next = temp;
}

eject
{
tail = tail->prev;
}
